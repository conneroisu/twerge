# Code Generation

Twerge provides powerful code generation capabilities, allowing you to generate Go code from class mappings for improved performance and type safety.

## The Problem

When using shortened class names in a production environment, you need:

1. A way to consistently map original Tailwind classes to short names
2. Fast lookups without runtime overhead
3. Type safety and compiler checks
4. Integration with build processes

## How Twerge Solves It

Twerge can generate Go code that contains the class mappings, providing compile-time checking and improved performance:

```go
import "github.com/conneroisu/twerge"

// Generate Go code for a variable containing the class mapping
code := twerge.GenerateClassMapCode()

// Write the generated code to a file
err := twerge.WriteClassMapFile("tailwind_classes_gen.go")
if err != nil {
    // Handle error
}
```

## Generated Code

The generated code will look something like this:

```go
// Code generated by Twerge - DO NOT EDIT.

package mypackage

// TailwindClassMap maps original Tailwind class strings to short generated class names
var TailwindClassMap = map[string]string{
    "flex items-center justify-between p-4": "tw-a1b2c3d4",
    "text-lg font-bold text-gray-800": "tw-e5f6g7h8",
    // ...many more mappings
}
```

## Using Generated Code

Once the code is generated, you can import and use it in your application:

```go
package main

import (
    "fmt"
    "./generated" // Package containing the generated code
)

func main() {
    // Get the short class name for a Tailwind class string
    className := generated.TailwindClassMap["flex items-center justify-between p-4"]

    // Use the class name in your HTML
    html := fmt.Sprintf(`<div class="%s">...</div>`, className)

    // ...
}
```

## Advanced Code Generation

Twerge uses the [Jennifer](https://github.com/dave/jennifer) library for code generation, allowing for sophisticated code generation capabilities.

### Customizing Generated Code

You can customize the generated code:

```go
// Set the package name for generated code
twerge.SetGeneratedPackage("tailwindclasses")

// Set the variable name for the class map
twerge.SetGeneratedMapName("ClassMap")

// Add custom imports to the generated code
twerge.AddGeneratedImport("github.com/example/mypackage")
```

### Generating Typed Functions

You can generate strongly typed functions for your most used classes:

```go
// Define the function types to generate
functionTypes := []string{
    "Button", "Card", "Header", "Footer",
}

// Generate code with typed functions
code := twerge.GenerateTypedFunctions(functionTypes)

// This might generate code like:
// func ButtonClasses() string {
//     return TailwindClassMap["flex items-center justify-between px-4 py-2 rounded bg-blue-500 text-white"]
// }
```

## Integration with Build Processes

Code generation is typically integrated into build processes:

### Example: Build Script

```go
package main

import (
    "github.com/conneroisu/twerge"
    "log"
    "os"
    "os/exec"
)

func main() {
    // 1. Collect all Tailwind classes from your templates
    classes := collectClassesFromTemplates()

    // 2. Register all classes
    for _, class := range classes {
        twerge.It(class)
    }

    // 3. Generate Go code
    err := twerge.WriteClassMapFile("internal/tailwind/classes_gen.go")
    if err != nil {
        log.Fatal(err)
    }

    // 4. Generate CSS for Tailwind
    err = twerge.GenerateInputCSSForTailwind("tailwind-input.css", "tailwind-output.css")
    if err != nil {
        log.Fatal(err)
    }

    // 5. Run Tailwind CLI
    cmd := exec.Command("npx", "tailwindcss", "-i", "tailwind-input.css", "-o", "public/css/styles.css", "--minify")
    cmd.Stdout = os.Stdout
    cmd.Stderr = os.Stderr
    err = cmd.Run()
    if err != nil {
        log.Fatal(err)
    }

    log.Println("Build completed successfully")
}

func collectClassesFromTemplates() []string {
    // Implementation to extract classes from templates
    // ...
}
```

### Integration with Go Generate

You can use `go generate` to automate the generation process:

```go
//go:generate go run ./tools/generate-tailwind-classes.go

package main

// ...
```

Then run:

```bash
go generate ./...
```

## Benefits of Code Generation

Using generated code provides several advantages:

1. **Performance** - No runtime hash computation or map lookups
2. **Type Safety** - Compile-time checking of class names
3. **Smaller Binary** - Compiled code can be optimized by the Go compiler
4. **Build-time Validation** - Issues are caught during the build process
5. **IDE Support** - Auto-completion and refactoring support in IDEs
