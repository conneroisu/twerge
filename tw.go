package twerge

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"

	"github.com/a-h/templ"
	"github.com/conneroisu/twerge/internal/files"
	"github.com/dave/jennifer/jen"
)

const (
	// twergeBeginMarker is the beginning of the section where the generated CSS will be placed
	twergeBeginMarker = "/* twerge:begin */"
	// twergeEndMarker is the end of the section where the generated CSS will be placed
	twergeEndMarker = "/* twerge:end */"
)

// CodeGen generates all the code needed to use Twerge statically.
func CodeGen(
	g *Generator,
	goPath string,
	cssPath string,
	htmlPath string,
	comps ...templ.Component,
) error {
	for _, comp := range comps {
		err := comp.Render(context.Background(), io.Discard)
		if err != nil {
			return err
		}
	}

	err := generateCSS(g, cssPath)
	if err != nil {
		return err
	}

	err = generateHTML(g, htmlPath)
	if err != nil {
		return err
	}

	err = generateGo(g, goPath)
	if err != nil {
		return err
	}

	return nil
}

// generateCSS creates an input CSS file for the Tailwind CLI
// that includes all the @apply directives from the provided class map.
//
// This is useful for building a production CSS file with Tailwind's CLI.
//
// The marker is used to identify the start and end of the @apply directives generated
// by Twerge.
func generateCSS(
	g *Generator,
	cssPath string,
) error {
	var builder bytes.Buffer
	keys, values := sortMap(g.Cache())
	for i, raw := range keys {
		builder.WriteString("/* from " + raw + " */\n")
		builder.WriteString(".")
		builder.WriteString(values[i].Generated)
		builder.WriteString(" { \n\t@apply ")
		builder.WriteString(values[i].Merged)
		builder.WriteString("; \n}\n\n")
	}
	cssContent := builder.Bytes()

	fil, err := os.OpenFile(cssPath, os.O_RDWR|os.O_CREATE, 0644)
	if os.IsNotExist(err) {
		fil, err = os.Create(cssPath)
		if err != nil {
			return fmt.Errorf("error creating file: %w", err)
		}
	}
	if err != nil {
		return fmt.Errorf("error opening file: %w", err)
	}
	defer func() {
		ferr := fil.Close()
		if ferr != nil {
			fmt.Printf("error closing css file: %v", ferr)
		}
	}()

	content, err := io.ReadAll(fil)
	if err != nil {
		return fmt.Errorf("error reading file: %w", err)
	}

	output, err := files.InteroplateMarkers(
		content,
		cssContent,
		[]byte(twergeBeginMarker),
		[]byte(twergeEndMarker),
	)

	if err != nil {
		return fmt.Errorf("error interpolating markers: %w", err)
	}

	err = os.WriteFile(cssPath, output, 0644)
	if err != nil {
		return fmt.Errorf("error writing file: %w", err)
	}

	return nil
}

// generateHTML creates a .templ file that can be used to generate a CSS file
// with the provided class map.
func generateHTML(
	g *Generator,
	htmlPath string,
) error {
	var buf bytes.Buffer
	buf.WriteString("<!-- Code generated by twerge. DO NOT EDIT. -->\n")
	buf.WriteString("\n\n")
	buf.WriteString("<div class=\"")
	buf.WriteString("mb-4")
	buf.WriteString("\"></div>\n")
	for k := range len(g.Cache()) {
		buf.WriteString("<div class=\"")
		buf.WriteString(fmt.Sprintf("tw-%d", k))
		buf.WriteString("\"></div>\n")
	}

	err := os.WriteFile(htmlPath, buf.Bytes(), 0644)
	if err != nil {
		return fmt.Errorf("error writing .templ file: %w", err)
	}

	return nil
}

// generateGo generates Go code for a variable containing the class mapping
func generateGo(
	g *Generator,
	goPath string,
) error {

	packageName, err := files.GetPackageName(goPath)
	if err != nil {
		return fmt.Errorf("error getting package name: %w", err)
	}
	// Create a new file
	f := jen.NewFile(packageName)

	// Add a package comment
	f.PackageComment("Code generated by twerge. DO NOT EDIT.")

	f.Func().Id("SetCache").Params().Block(
		jen.Qual("github.com/conneroisu/twerge", "Default").
			Call().Dot("Handler").Dot("SetCache").Call(jen.Id("ClassMapStr")),
	)

	// Create the ClassMapStr variable
	f.Var().Id("ClassMapStr").Op("=").Map(jen.String()).Qual(
		"github.com/conneroisu/twerge",
		"CacheValue",
	).Values(jen.DictFunc(func(d jen.Dict) {
		for k := range g.Cache() {
			d[jen.Lit(k)] = jen.Qual(
				"github.com/conneroisu/twerge",
				"CacheValue",
			).Values(jen.Dict{
				jen.Id("Generated"): jen.Lit(g.Cache()[k].Generated),
				jen.Id("Merged"):    jen.Lit(g.Cache()[k].Merged),
			})
		}
	}))

	return files.JenFile(f, goPath)
}

// sortMap takes a map of string to CacheValue and returns two slices:
// 1. A slice of sorted keys (sorted by the numeric part of the "tw-{num}" in the Generated field)
// 2. A slice of corresponding CacheValues in the same order
func sortMap(m map[string]CacheValue) ([]string, []CacheValue) {
	// Create a slice of keys
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}

	// Sort keys based on the numeric part of the Generated field
	sort.Slice(keys, func(i, j int) bool {
		numI := extractNumber(m[keys[i]].Generated)
		numJ := extractNumber(m[keys[j]].Generated)
		return numI < numJ
	})

	// Create a slice of values in the same order as sorted keys
	values := make([]CacheValue, len(keys))
	for i, k := range keys {
		values[i] = m[k]
	}

	return keys, values
}

// extractNumber extracts the numeric part from "tw-{num}"
func extractNumber(generated string) int {
	// Split by "-" and get the last part
	parts := strings.Split(generated, "-")
	if len(parts) < 2 {
		return 0
	}

	// Convert to int
	num, err := strconv.Atoi(parts[len(parts)-1])
	if err != nil {
		return 0
	}

	return num
}
